import type { Config } from '@cleancue/shared';
import { promises as fs } from 'fs';
import path from 'path';
import os from 'os';

const DEFAULT_CONFIG: Config = {
  database: {
    path: path.join(os.homedir(), '.cleancue', 'library.db')
  },
  workers: {
    maxConcurrent: Math.max(1, Math.floor(os.cpus().length / 2)),
    timeout: 300000, // 5 minutes
    python: {
      executable: 'python3'
    }
  },
  analyzers: {
    tempo: {
      enabled: true,
      primary: true,
      parameters: {
        hop_length: 512,
        start_bpm: 120,
        std_bpm: 4.0
      }
    },
    key: {
      enabled: true,
      parameters: {
        profile: 'temperley'
      }
    },
    energy: {
      enabled: true,
      parameters: {
        hop_length: 512,
        frame_length: 2048,
        window_size: 4096
      }
    },
    loudness: {
      enabled: true,
      parameters: {
        block_size: 0.400,
        hop_size: 0.100
      }
    },
    silence: {
      enabled: false,
      parameters: {
        threshold: -40,
        min_duration: 1.0
      }
    }
  },
  export: {
    defaultFormat: 'm3u',
    outputDir: path.join(os.homedir(), 'Desktop')
  },
  scanning: {
    supportedExtensions: ['mp3', 'wav', 'flac', 'm4a', 'aac', 'ogg', 'wma'],
    followSymlinks: false,
    respectGitignore: true
  }
};

export class ConfigManager {
  private config: Config;
  private configPath: string;

  constructor(configPath?: string) {
    this.configPath = configPath || this.getDefaultConfigPath();
    this.config = this.loadConfig();
  }

  private getDefaultConfigPath(): string {
    const configDir = path.join(os.homedir(), '.cleancue');
    return path.join(configDir, 'config.json');
  }

  private loadConfig(): Config {
    try {
      const configData = require(this.configPath);
      return this.mergeConfig(DEFAULT_CONFIG, configData);
    } catch (error) {
      console.log('Using default configuration');
      return { ...DEFAULT_CONFIG };
    }
  }

  private mergeConfig(defaultConfig: Config, userConfig: any): Config {
    const merged = { ...defaultConfig };
    
    for (const [key, value] of Object.entries(userConfig)) {
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        merged[key as keyof Config] = {
          ...merged[key as keyof Config] as any,
          ...value
        };
      } else {
        (merged as any)[key] = value;
      }
    }

    return merged;
  }

  get<T = any>(path: string): T {
    const keys = path.split('.');
    let current: any = this.config;
    
    for (const key of keys) {
      if (current[key] === undefined) {
        throw new Error(`Configuration key not found: ${path}`);
      }
      current = current[key];
    }
    
    return current as T;
  }

  getAll(): Config {
    return { ...this.config };
  }

  update(updates: Partial<Config>): void {
    this.config = this.mergeConfig(this.config, updates);
  }

  async save(): Promise<void> {
    const configDir = path.dirname(this.configPath);
    
    try {
      await fs.mkdir(configDir, { recursive: true });
      await fs.writeFile(
        this.configPath, 
        JSON.stringify(this.config, null, 2), 
        'utf8'
      );
    } catch (error) {
      const err = error as Error;
      throw new Error(`Failed to save configuration: ${err.message}`);
    }
  }

  async ensureDirectories(): Promise<void> {
    const dirsToCreate = [
      path.dirname(this.config.database.path),
      this.config.export.outputDir
    ];

    for (const dir of dirsToCreate) {
      try {
        await fs.mkdir(dir, { recursive: true });
      } catch (error) {
        console.warn(`Failed to create directory ${dir}:`, error);
      }
    }
  }
}